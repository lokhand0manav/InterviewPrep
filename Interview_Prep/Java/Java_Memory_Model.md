- Reference : https://medium.com/platform-engineer/understanding-java-memory-model-1d0863f6d973
 - Inside JVM, there exist separate memory spaces (Heap, Non-Heap, Cache) in order to store runtime data and compiled code.
 - **Heap Memory**:
	 - Heap is divided into 2 parts — **Young Generation** and **Old Generation**
	 - Heap is allocated when JVM starts up (Initial size: -Xms)
	 - ![[Pasted image 20220821172902.png]]
		 - Young Generation : minor GC, survived objects are pushed further and eventually added to OLD
		 - Old Generation : Once full, major GC happens 
 - **Non Heap Memory**
	 - ![[Pasted image 20220821173144.png]]
	 - This includes **Permanent Generation** (Replaced by **Metaspace** since Java 8)
	 - Perm Gen stores per-class structures such as runtime constant pool, field and method data, and the code for methods and constructors, as well as interned Strings
 - **Cache memory**
	 - This includes **Code Cache**
	 - Stores compiled code (i.e. native code) generated by JIT compiler, JVM internal structures, loaded profiler agent code and data, etc.
	 - When Code Cache exceeds a threshold, it gets flushed (and objects are not relocated by the GC).
 - **Heap vs Stack**
	 - ![[Pasted image 20220821173524.png]]
	 - ![[Pasted image 20220821173544.png]]
	 - **Working**
		 - `class Person {  `
			    `int pid;  `
			    `String name;// constructor, setters/getters`  
			`}`
			`public class Driver {`  
			    `public static void main(String[] args) {`  
			        `int id = 23;  `
			        `String pName = "Jon";  `
			        `Person p = null;  `
			        `p = new Person(id, pName);  `
			    `}  `
			`}`
		 - ![[Pasted image 20220821174108.png]]